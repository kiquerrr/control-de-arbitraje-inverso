# -*- coding: utf-8 -*-
# ==========================================================
# ARCHIVO: main.py
# DESCRIPCION: Script principal mejorado v2.0
# MEJORAS: Validaciones, backups, preview, reportes integrados
# ==========================================================

import math
import pandas as pd
import os
from datetime import date
from arbitraje_core import CicloArbitraje
from utils import (crear_backup, validar_numero_positivo, validar_entero_rango, 
                   confirmar_accion, formatear_moneda, formatear_porcentaje,
                   imprimir_titulo, imprimir_separador)
from reportes import generar_reporte_ciclo, mostrar_ultimos_dias

# ==========================================================
# --- 1. PARAMETROS DE CONFIGURACION DEL PROYECTO ---
# ==========================================================

# Parametros del ciclo (Configurables)
DIAS_CICLO_DEFAULT = 30
LIMITE_FINAL_USD = 1000.00
MAX_CICLOS_DIARIOS = 3

# Parametros Financieros (Base para sugerencias)
COSTO_COMPRA_BASE = 1.04424
COMISION_P2P_MAKER = 0.0035
TASA_VENTA_OBJETIVO = 1.12895

# Parametros de Inversion
PORCENTAJE_AHORRO_BTC = 0.50

# Archivos y Saldo
ARCHIVO_HISTORICO = 'data/historico_arbitraje.csv'
ARCHIVO_CONFIG = 'data/config_ciclo.txt'

# --------------------------------------------------------------------------
# --- 2. FUNCIONES DE GESTION DE SALDO Y ESTADO ---
# --------------------------------------------------------------------------

def guardar_estado(saldo: float, dias_ciclo: int, capital_inicial_global: float):
    """Guarda el saldo total y la duracion del ciclo."""
    os.makedirs(os.path.dirname(ARCHIVO_HISTORICO), exist_ok=True)
    with open(ARCHIVO_CONFIG, 'w') as f:
        f.write(f"SALDO:{round(saldo, 2)}\n")
        f.write(f"DIAS:{dias_ciclo}\n")
        f.write(f"C_INICIAL_GLOBAL:{round(capital_inicial_global, 2)}")

def cargar_estado():
    """Carga el saldo, la duracion del ciclo y el capital inicial global o pide iniciar."""
    if os.path.exists(ARCHIVO_CONFIG):
        try:
            with open(ARCHIVO_CONFIG, 'r') as f:
                lines = f.readlines()
                saldo = float(lines[0].split(':')[1].strip())
                dias = int(lines[1].split(':')[1].strip())
                try:
                    capital_global = float(lines[2].split(':')[1].strip())
                except (IndexError, ValueError):
                    capital_global = 0.0
            return saldo, dias, capital_global
        except Exception as e:
            print(f"?? Error al cargar estado: {e}")
            print("?? Se crear√° un nuevo ciclo.")
            return 0.0, 0, 0.0
    return 0.0, 0, 0.0

def calcular_capital_inicial_ajustado(modelo: CicloArbitraje) -> float:
    """Calcula el capital inicial optimo para el Dia 1."""
    try:
        tasa_crecimiento = modelo.get_tasa_rentabilidad_por_ciclo()
        factor_crecimiento_total = (1 + tasa_crecimiento) ** modelo.DIAS_CICLO
        return modelo.LIMITE_FINAL_USD / factor_crecimiento_total
    except ValueError:
        return 0.0

def calcular_tasa_publicacion_sugerida(tasa_mercado: float, costo_compra: float, comision: float) -> float:
    """Calcula la tasa de venta sugerida basada en el 2% de rentabilidad neta."""
    rentabilidad_objetivo = 0.02
    tasa_publicacion_objetivo = costo_compra * (1 + rentabilidad_objetivo) / (1 - comision)
    return min(tasa_mercado, tasa_publicacion_objetivo)

def crear_dataframe_vacio():
    """Crea estructura base del DataFrame"""
    return pd.DataFrame(columns=[
        'Dia', 'Fecha', 'C_Inicial_USD', 'Tasa_Venta_P2P', 'Ciclos_Completados',
        'USDT_Comprado_Total', 'Ganancia_Bruta_Diaria', 'Ganancia_Retenida', 
        'Ganancia_Retirada', 'C_Final_USD', 'Costo_Compra_USD', 
        'Comision_P2P_Aplicada', 'Tipo_Operacion', 'ROI_Dia'
    ])

def cargar_historial() -> pd.DataFrame:
    """Carga el historial desde CSV o crea un nuevo DataFrame."""
    if os.path.exists(ARCHIVO_HISTORICO):
        try:
            df = pd.read_csv(ARCHIVO_HISTORICO)
            
            # Validar columnas minimas
            columnas_requeridas = ['Dia', 'Fecha', 'C_Inicial_USD']
            if not all(col in df.columns for col in columnas_requeridas):
                print("?? CSV corrupto. Creando backup y nuevo archivo.")
                crear_backup(ARCHIVO_HISTORICO)
                return crear_dataframe_vacio()
            
            # Migrar columnas antiguas si es necesario
            if 'Ganancia_Neta_Diaria' in df.columns and 'Ganancia_Bruta_Diaria' not in df.columns:
                df['Ganancia_Bruta_Diaria'] = df['Ganancia_Neta_Diaria']
                df['Ganancia_Retenida'] = df['Ganancia_Neta_Diaria']
                df['Ganancia_Retirada'] = 0.0
                df['Tipo_Operacion'] = 'LEGACY'
                df['ROI_Dia'] = (df['Ganancia_Bruta_Diaria'] / df['C_Inicial_USD'] * 100).fillna(0)
            
            return df
            
        except Exception as e:
            print(f"? Error al leer CSV: {e}")
            crear_backup(ARCHIVO_HISTORICO)
            return crear_dataframe_vacio()
    else:
        return crear_dataframe_vacio()

def guardar_registro(df_historico: pd.DataFrame, nuevo_registro: dict):
    """A√±ade un nuevo registro y guarda el DataFrame en CSV."""
    # Crear backup antes de guardar
    if os.path.exists(ARCHIVO_HISTORICO):
        crear_backup(ARCHIVO_HISTORICO)
    
    os.makedirs(os.path.dirname(ARCHIVO_HISTORICO), exist_ok=True)
    df_actualizado = pd.concat([df_historico, pd.DataFrame([nuevo_registro])], ignore_index=True)
    df_actualizado.to_csv(ARCHIVO_HISTORICO, index=False)
    return df_actualizado

def resumen_final(df_historico: pd.DataFrame, saldo_final_boveda: float, dias_ciclo_total: int, capital_inicial_global: float):
    """Genera el resumen final del ciclo mejorado."""
    
    ganancia_neta_total_real = saldo_final_boveda - capital_inicial_global
    roi_total = (ganancia_neta_total_real / capital_inicial_global) * 100 if capital_inicial_global > 0 else 0
    
    # Calcular ROI diario promedio compuesto
    if dias_ciclo_total > 0 and capital_inicial_global > 0:
        roi_diario_promedio = ((saldo_final_boveda / capital_inicial_global) ** (1/dias_ciclo_total) - 1) * 100
    else:
        roi_diario_promedio = 0

    imprimir_titulo("?? RESUMEN DE CIERRE DE CICLO")
    
    print(f"\n??  DURACI√ìN DEL CICLO: {dias_ciclo_total} D√≠as")
    print(f"?? CAPITAL INICIAL: {formatear_moneda(capital_inicial_global)}")
    print(f"?? CAPITAL FINAL: {formatear_moneda(saldo_final_boveda)} (L√≠mite: {formatear_moneda(LIMITE_FINAL_USD)})")
    print(f"?? GANANCIA NETA TOTAL: {formatear_moneda(ganancia_neta_total_real)}")
    print(f"?? ROI TOTAL: {formatear_porcentaje(roi_total)}")
    print(f"?? ROI DIARIO PROMEDIO (Compuesto): {formatear_porcentaje(roi_diario_promedio, 3)}")
    
    imprimir_separador("-")

    # PLAN DE AHORRO BTC
    monto_ahorro_btc = ganancia_neta_total_real * PORCENTAJE_AHORRO_BTC
    monto_utilidad_operativa = saldo_final_boveda - monto_ahorro_btc

    print(f"\n?? DISTRIBUCI√ìN DE GANANCIAS:")
    print(f"   1. AHORRO EN BITCOIN ({PORCENTAJE_AHORRO_BTC*100:.0f}%): {formatear_moneda(monto_ahorro_btc)} ? Convertir a BTC")
    print(f"   2. CAPITAL PARA PR√ìXIMO CICLO: {formatear_moneda(monto_utilidad_operativa)}")
    
    imprimir_separador("-")
    
    # Estadisticas adicionales del ciclo
    total_usdt_operado = df_historico['USDT_Comprado_Total'].sum()
    total_ciclos = df_historico['Ciclos_Completados'].sum()
    
    print(f"\n?? ESTAD√çSTICAS DEL CICLO:")
    print(f"   Total USDT Operado: {total_usdt_operado:,.2f} USDT")
    print(f"   Total Ciclos Completados: {total_ciclos}")
    print(f"   Promedio Ciclos/D√≠a: {total_ciclos/dias_ciclo_total:.1f}")
    
    # Calcular comisiones totales pagadas
    if 'Comision_P2P_Aplicada' in df_historico.columns:
        comisiones_totales = (df_historico['USDT_Comprado_Total'] * 
                             df_historico['Tasa_Venta_P2P'] * 
                             df_historico['Comision_P2P_Aplicada']).sum()
        print(f"   Comisiones P2P Pagadas: {formatear_moneda(comisiones_totales)}")
    
    imprimir_separador()

def preview_operacion(capital: float, tasa_venta: float, costo_compra: float, ciclos: int):
    """Muestra una proyeccion de la operacion antes de confirmar"""
    
    try:
        simulacion = CicloArbitraje(
            capital_inicial_usd=capital,
            tasa_venta_p2p_publicada=tasa_venta,
            costo_compra_usdt=costo_compra,
            comision_p2p_maker=COMISION_P2P_MAKER,
            dias_ciclo=30,
            limite_final_usd=LIMITE_FINAL_USD,
            max_ciclos_diarios=MAX_CICLOS_DIARIOS
        )
        
        breakdown = simulacion.breakdown_operacion(capital, ciclos)
        
        imprimir_titulo("?? PROYECCI√ìN DE LA OPERACI√ìN", "=")
        
        print(f"\n?? DATOS DE ENTRADA:")
        print(f"   Capital a Operar:      {formatear_moneda(capital)}")
        print(f"   Tasa de Venta P2P:     {tasa_venta:.4f} USD/USDT")
        print(f"   Costo de Compra:       {costo_compra:.4f} USD/USDT")
        print(f"   Ciclos a Completar:    {ciclos}")
        print(f"   Comisi√≥n P2P:          {formatear_porcentaje(COMISION_P2P_MAKER * 100)}")
        
        print(f"\n?? RESULTADOS PROYECTADOS:")
        print(f"   USDT Total a Operar:   {breakdown['usdt_total_comprado']:,.2f} USDT")
        print(f"   Ingreso Bruto Venta:   {formatear_moneda(breakdown['ingreso_bruto_venta'])}")
        print(f"   Comisiones P2P:        {formatear_moneda(breakdown['comisiones_p2p'])}")
        print(f"   Ingreso Neto Venta:    {formatear_moneda(breakdown['ingreso_neto_venta'])}")
        print(f"   Ganancia Neta:         {formatear_moneda(breakdown['ganancia_neta'])}")
        print(f"   Capital Final:         {formatear_moneda(breakdown['capital_final'])}")
        print(f"   ROI del D√≠a:           {formatear_porcentaje(breakdown['roi_dia'])}")
        print(f"   Rentabilidad/Ciclo:    {formatear_porcentaje(breakdown['rentabilidad_por_ciclo'])}")
        
        imprimir_separador()
        
        return confirmar_accion("\n¬øConfirmar operaci√≥n?")
        
    except ValueError as e:
        print(f"\n? ERROR: {e}")
        return False

# --------------------------------------------------------------------------
# --- 3. FUNCION DE EJECUCION DIARIA ---
# --------------------------------------------------------------------------

def ejecutar_dia():
    """Funcion principal que maneja la logica de ejecucion diaria mejorada."""

    df_historico = cargar_historial()
    saldo_boveda, DIAS_CICLO_ACTUAL, CAPITAL_INICIAL_GLOBAL = cargar_estado()

    # 3.1 GESTION DEL CICLO (INICIO O CONTINUACION)

    if DIAS_CICLO_ACTUAL == 0:
        # --- INICIO DEL MACRO CICLO (DIA 1) ---
        dia_actual = 1
        imprimir_titulo("?? INICIO DE NUEVO CICLO")
        
        DIAS_CICLO_ACTUAL = validar_entero_rango(
            "-> Ingrese la duraci√≥n total del ciclo (1-90 d√≠as): ", 1, 90
        )
        
        saldo_boveda = 0.0
        CAPITAL_INICIAL_GLOBAL = 0.0

    else:
        # --- CONTINUACION DEL MACRO CICLO ---
        if df_historico.empty:
            # Si el historial est· vacÌo pero hay estado guardado, hay inconsistencia
            print("?? ADVERTENCIA: Hay estado guardado pero sin historial.")
            if confirmar_accion("øReiniciar desde dÌa 1?"):
                dia_actual = 1
                saldo_boveda = 0.0
                CAPITAL_INICIAL_GLOBAL = 0.0
            else:
                print("? OperaciÛn cancelada.")
                return
        else:
            ultimo_registro = df_historico.iloc[-1]
            dia_actual = int(ultimo_registro['Dia']) + 1

        if dia_actual > DIAS_CICLO_ACTUAL:
            print(f"\n? EL CICLO HA FINALIZADO (D√≠a {DIAS_CICLO_ACTUAL}).")
            resumen_final(df_historico, saldo_boveda, DIAS_CICLO_ACTUAL, CAPITAL_INICIAL_GLOBAL)
            
            if confirmar_accion("\n¬øDesea ver el reporte detallado?"):
                generar_reporte_ciclo(ARCHIVO_HISTORICO, CAPITAL_INICIAL_GLOBAL)
            
            if confirmar_accion("\n¬øDesea iniciar un nuevo ciclo?"):
                os.remove(ARCHIVO_CONFIG)
                print("? Configuraci√≥n limpiada. Ejecute el script nuevamente.")
            return

    # Sugerencias
    costo_compra_sugerido = df_historico.iloc[-1]['Costo_Compra_USD'] if not df_historico.empty else COSTO_COMPRA_BASE

    imprimir_separador()
    print(f"\n?? D√çA DE OPERACI√ìN: {dia_actual} de {DIAS_CICLO_ACTUAL}")
    print(f"?? SALDO EN B√ìVEDA (ACUMULADO): {formatear_moneda(saldo_boveda)}")
    imprimir_separador("-")

    # Mostrar ultimos dias si no es dia 1
    if dia_actual > 1:
        if confirmar_accion("\n¬øVer √∫ltimos 3 d√≠as?"):
            mostrar_ultimos_dias(ARCHIVO_HISTORICO, 3)

    # 3.2 PASO 1 Y 2: COMPRA DE CAPITAL (TARJETA)

    capital_actual = 0.0
    tipo_operacion = ""

    # Flujo de capital: Pregunta si quiere usar el saldo acumulado o agregar nuevo
    if saldo_boveda > 0 and dia_actual > 1:
        # Dias > 1: Usar saldo disponible
        print(f"\n?? Capital acumulado disponible en B√≥veda: {formatear_moneda(saldo_boveda)}")
        
        capital_actual = validar_numero_positivo(
            f"-> PASO 1: Monto USD a operar hoy (Enter = {formatear_moneda(saldo_boveda)}): ",
            default=saldo_boveda,
            maximo=saldo_boveda
        )

        costo_compra_actual = 1.0  # Ya est√° en USD
        tipo_operacion = "REINVERSION"

    else:
        # Dia 1 o Boveda en cero: Obligado a inyectar capital fresco
        print("\n?? B√≥veda vac√≠a o D√≠a 1. Debe inyectar capital fresco (Tarjeta).")
        
        capital_actual = validar_numero_positivo(
            f"-> PASO 1: Monto USD a COMPRAR hoy (Capital Inicial): "
        )
        
        if capital_actual > LIMITE_FINAL_USD:
            print(f"?? ADVERTENCIA: El monto excede el l√≠mite final ({formatear_moneda(LIMITE_FINAL_USD)}).")
            if not confirmar_accion("¬øContinuar bajo riesgo?"):
                return

        costo_compra_actual = validar_numero_positivo(
            f"-> PASO 2: Costo USDT/Tarjeta (Sugerido {costo_compra_sugerido:.4f}): ",
            default=costo_compra_sugerido
        )

        tipo_operacion = "CAPITAL_FRESCO"

        # REGISTRO CR√çTICO DEL CAPITAL GLOBAL INICIAL (Solo Dia 1)
        if dia_actual == 1:
            CAPITAL_INICIAL_GLOBAL = capital_actual
            saldo_boveda += capital_actual

    # Validacion de limite diario (50% del limite final)
    if capital_actual > LIMITE_FINAL_USD * 0.5:
        print(f"\n?? ADVERTENCIA: Operar m√°s del 50% del l√≠mite ({formatear_moneda(LIMITE_FINAL_USD * 0.5)}) puede ser riesgoso.")
        if not confirmar_accion("¬øDesea continuar?"):
            return

    # 3.2 AJUSTE DE SALDO DE BOVEDA (Retirar el capital para operar)
    saldo_boveda -= capital_actual

    # 3.3 PASO 3: CALCULAR TASA DE VENTA Y PUBLICAR

    tasa_ingresada = None
    simulacion = None

    while True:
        try:
            tasa_p2p_mercado = validar_numero_positivo(
                f"\n-> PASO 3a: Tasa P2P promedio de Venta (Competencia): "
            )

            tasa_publicacion_sugerida = calcular_tasa_publicacion_sugerida(
                tasa_p2p_mercado, costo_compra_actual, COMISION_P2P_MAKER
            )

            tasa_ingresada = validar_numero_positivo(
                f"-> PASO 3b: Tasa Real de Venta a publicar (Sugerida {tasa_publicacion_sugerida:.4f}): ",
                default=tasa_publicacion_sugerida
            )

            # Validar rentabilidad
            simulacion = CicloArbitraje(
                capital_inicial_usd=capital_actual,
                tasa_venta_p2p_publicada=tasa_ingresada,
                costo_compra_usdt=costo_compra_actual,
                comision_p2p_maker=COMISION_P2P_MAKER,
                dias_ciclo=DIAS_CICLO_ACTUAL, 
                limite_final_usd=LIMITE_FINAL_USD,
                max_ciclos_diarios=MAX_CICLOS_DIARIOS
            )

            rentabilidad_ciclo = simulacion.get_rentabilidad_porcentual_por_ciclo()
            
            if rentabilidad_ciclo < 0:
                print(f"? La tasa NO es rentable. Margen: {formatear_porcentaje(rentabilidad_ciclo, 3)}.")
                continue

            if rentabilidad_ciclo > 2.0:
                print(f"?? Margen alto ({formatear_porcentaje(rentabilidad_ciclo)}). ¬°Cuidado con la competitividad!")

            print(f"? Tasa rentable. Margen por ciclo: {formatear_porcentaje(rentabilidad_ciclo)}")
            break
            
        except ValueError as e:
            print(f"? Error: {e}")
            continue

    # 3.4 PASO 4: VENTA Y CALCULO DE GANANCIA

    ciclos = validar_entero_rango(
        f"\n-> PASO 4: Ciclos Completados (Max {MAX_CICLOS_DIARIOS}): ", 
        1, 
        MAX_CICLOS_DIARIOS
    )

    # PREVIEW DE LA OPERACION
    if not preview_operacion(capital_actual, tasa_ingresada, costo_compra_actual, ciclos):
        print("\n? Operaci√≥n cancelada por el usuario.")
        # Devolver capital a la boveda
        saldo_boveda += capital_actual
        guardar_estado(saldo_boveda, DIAS_CICLO_ACTUAL, CAPITAL_INICIAL_GLOBAL)
        return

    # Calculos finales
    ganancia_bruta_diaria = simulacion.calcular_ganancia_neta(capital_actual, ciclos_completados=ciclos)
    usdt_total_comprado = simulacion.calcular_usdt_comprado(capital_actual, ciclos_completados=ciclos)

    # 3.5 PASO 5: CIERRE Y REINVERSION

    capital_final_operacion = capital_actual + ganancia_bruta_diaria

    # Devolver el monto total de la operacion a la Boveda
    saldo_boveda += capital_final_operacion

    print(f"\n?? Ganancia Bruta del D√≠a: {formatear_moneda(ganancia_bruta_diaria)}")
    
    ganancia_retenida = 0.0
    ganancia_retirada = 0.0

    if confirmar_accion(f"-> PASO 5: ¬øDesea RETIRAR la ganancia ({formatear_moneda(ganancia_bruta_diaria)})?"):
        # Retiro: Se retira la ganancia
        saldo_boveda -= ganancia_bruta_diaria
        ganancia_retirada = ganancia_bruta_diaria
        ganancia_retenida = 0.0
        print(f"? Retiro completado. {formatear_moneda(ganancia_bruta_diaria)} retirado de la b√≥veda.")
    else:
        # Reinversion total
        ganancia_retenida = ganancia_bruta_diaria
        ganancia_retirada = 0.0
        print(f"? Reinversi√≥n total. {formatear_moneda(ganancia_bruta_diaria)} permanece en la b√≥veda.")

    # Aplicar el limite (Si estamos en el ultimo dia, el saldo debe ser LIMITE_FINAL_USD)
    if dia_actual == DIAS_CICLO_ACTUAL:
        if saldo_boveda > LIMITE_FINAL_USD:
            exceso = saldo_boveda - LIMITE_FINAL_USD
            print(f"\n?? L√≠mite alcanzado. Exceso de {formatear_moneda(exceso)} ser√° ajustado.")
            ganancia_retenida -= exceso
            saldo_boveda = LIMITE_FINAL_USD
            capital_final_operacion = LIMITE_FINAL_USD

    # Calcular ROI del dia
    roi_dia = (ganancia_bruta_diaria / capital_actual) * 100 if capital_actual > 0 else 0

    # 3.6 REGISTRO
    nuevo_registro = {
        'Dia': dia_actual, 
        'Fecha': date.today().strftime("%Y-%m-%d"),
        'C_Inicial_USD': round(capital_actual, 2), 
        'Tasa_Venta_P2P': tasa_ingresada,
        'Ciclos_Completados': ciclos, 
        'USDT_Comprado_Total': round(usdt_total_comprado, 4),
        'Ganancia_Bruta_Diaria': round(ganancia_bruta_diaria, 2),
        'Ganancia_Retenida': round(ganancia_retenida, 2),
        'Ganancia_Retirada': round(ganancia_retirada, 2),
        'C_Final_USD': round(capital_final_operacion, 2),
        'Costo_Compra_USD': simulacion.COSTO_COMPRA_TARJETA, 
        'Comision_P2P_Aplicada': simulacion.COMISION_BINANCE_P2P,
        'Tipo_Operacion': tipo_operacion,
        'ROI_Dia': round(roi_dia, 2)
    }

    df_historico = guardar_registro(df_historico, nuevo_registro)
    guardar_estado(saldo_boveda, DIAS_CICLO_ACTUAL, CAPITAL_INICIAL_GLOBAL)

    # Reporte
    imprimir_titulo("? RESUMEN DEL D√çA")
    print(f"\n?? Ganancia Bruta del D√≠a:       {formatear_moneda(ganancia_bruta_diaria)}")
    print(f"?? Ganancia Retenida (B√≥veda):   {formatear_moneda(ganancia_retenida)}")
    print(f"?? Ganancia Retirada:             {formatear_moneda(ganancia_retirada)}")
    print(f"?? SALDO B√ìVEDA para ma√±ana:     {formatear_moneda(saldo_boveda)}")
    print(f"?? ROI del D√≠a:                   {formatear_porcentaje(roi_dia)}")
    imprimir_separador()

    if dia_actual == DIAS_CICLO_ACTUAL:
        resumen_final(df_historico, saldo_boveda, DIAS_CICLO_ACTUAL, CAPITAL_INICIAL_GLOBAL)
        
        if confirmar_accion("\n¬øDesea ver el reporte detallado completo?"):
            generar_reporte_ciclo(ARCHIVO_HISTORICO, CAPITAL_INICIAL_GLOBAL)
        
        # Limpiar archivos de configuracion para proximo ciclo
        if confirmar_accion("\n¬øLimpiar configuraci√≥n para nuevo ciclo?"):
            os.remove(ARCHIVO_CONFIG)
            print("? Configuraci√≥n limpiada.")

    elif dia_actual < DIAS_CICLO_ACTUAL:
        print(f"\n? Historial guardado. Listo para operar el D√≠a {dia_actual + 1}.")

# --------------------------------------------------------------------------
# --- 4. MENU PRINCIPAL ---
# --------------------------------------------------------------------------

def menu_principal():
    """Menu principal con opciones adicionales"""
    
    while True:
        imprimir_titulo("?? CONTROL DE ARBITRAJE P2P - MEN√ö PRINCIPAL")
        print("\n1. ?? Ejecutar Operaci√≥n del D√≠a")
        print("2. ?? Ver Reporte del Ciclo Actual")
        print("3. ?? Ver √öltimos 5 D√≠as")
        print("4. ?? Reiniciar Ciclo (Limpiar Estado)")
        print("5. ?? Crear Backup Manual")
        print("6. ?? Salir")
        imprimir_separador()
        
        opcion = input("\nSeleccione una opci√≥n (1-6): ").strip()
        
        if opcion == "1":
            ejecutar_dia()
            input("\nPresione Enter para continuar...")
        
        elif opcion == "2":
            _, _, capital_inicial = cargar_estado()
            generar_reporte_ciclo(ARCHIVO_HISTORICO, capital_inicial)
            input("\nPresione Enter para continuar...")
        
        elif opcion == "3":
            mostrar_ultimos_dias(ARCHIVO_HISTORICO, 5)
            input("\nPresione Enter para continuar...")
        
        elif opcion == "4":
            if confirmar_accion("?? ¬øEst√° seguro de reiniciar el ciclo? Se perder√° el progreso actual"):
                if os.path.exists(ARCHIVO_CONFIG):
                    crear_backup(ARCHIVO_CONFIG)
                    os.remove(ARCHIVO_CONFIG)
                    print("? Ciclo reiniciado.")
                else:
                    print("?? No hay ciclo activo.")
            input("\nPresione Enter para continuar...")
        
        elif opcion == "5":
            crear_backup(ARCHIVO_HISTORICO)
            crear_backup(ARCHIVO_CONFIG)
            input("\nPresione Enter para continuar...")
        
        elif opcion == "6":
            print("\n?? ¬°Hasta luego!")
            break
        
        else:
            print("? Opci√≥n no v√°lida.")
            input("\nPresione Enter para continuar...")


if __name__ == "__main__":
    try:
        menu_principal()
    except KeyboardInterrupt:
        print("\n\n?? Operaci√≥n interrumpida por el usuario.")
    except Exception as e:
        print(f"\n? ERROR FATAL: {e}")
        import traceback
        traceback.print_exc()